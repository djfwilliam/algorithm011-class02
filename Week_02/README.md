# 学习笔记 #
# 1. 哈希表、映射、集合的实现与特性 #

1. 哈希表（Hash table）也叫散列表。可以根据关键码直接访问数据。  
2. 它通过哈希函数（Hash Function）把关键码映射到表中的一个位置，来加快访问速度。  
3. 哈希碰撞工程中常用解决方式：拉链式，通过增加一个链表来实现。  
4. 平均查询时间复杂度：O(1)，如果哈希函数不好，查询则会退化到O(n)。 
## 1.1 Java中的使用： ##
1. Map：key-value形式，key不重复，定义为一个接口
2. HashMap() ，TreeMap() 二叉搜索树 内部用红黑树实现  
	put(key, value)  
	get(key)
	containsKey(key)，containsValue(value)  
	size()  
	clear()
3. Set：不重复的元素集合，定义为一个接口
4. HashSet()，TreeSet() 二叉搜索树 内部用红黑树实现  
	add(value)  
	remove(value)  
	contains(value)
## 1.2 HashMap 源码分析（小结） ## 
Java中的HashSet内部是基于HashMap实现的，每次存的value是一个空的Object。所以这里我们着重看一下HashMap的源码。  
参考资料：  
> [HashMap原理深入理解](https://blog.csdn.net/visant/article/details/80045154)   
> [来复习一波，HashMap底层实现原理解析](http://baijiahao.baidu.com/s?id=1665667572592680093&wfr=spider&for=pc)  
> [JDK 源码中 HashMap 的 hash 方法原理是什么？](https://www.zhihu.com/question/20733617)  
> [Java8 HashMap源码分析](https://link.zhihu.com/?target=https%3A//blog.csdn.net/mq2553299/article/details/76858495)  

- put(K key, V value) 存数据


- get(Object key) 取数据

# 2. 树、二叉树、二叉搜索树的实现与特性 #
## 2.1 二叉树的遍历 ##
- 前序遍历：根 - 左 - 右  
- 中序遍历：左 - 根 - 右  
- 后序遍历：左 - 右 - 根  

## 2.2 二叉搜索树特性： ##
- 左子树上所有节点值都小于根节点的值
- 右子树上所有节点值都大于根节点的值
- 中序遍历为升序排列
- 查询、插入、删除时间复杂度都为O(log n)，退化成链表时最坏O(n)

# 3. 堆和二叉堆、图 #
## 3.1 堆 ##
可以迅速找到一堆数中的最大值或最小值的数据结构。  
如果根节点的值最大叫大顶堆，根节点的值最小叫小顶堆。  
堆的实现有好多种，常见的二叉堆、斐波那契堆等。  

常见操作时间复杂度： 

- 查找最大/最小值：O(1)
- 删除最大/最小值：O(log n)
- 插入元素：O(log n)，最好情况O(1)
## 3.2 二叉堆 ##
通过完全二叉树实现（不是二叉搜索树）。

性质：  

- 是一颗完全树。  
- 树中任意节点的值总是大于等于子节点的值。

实现：  

- 一般通过数组实现。
- 假设第一个数组索引为0，父节点和子节点关系如下：  
- i节点的左孩子索引为：2*i+1  
- i节点的右孩子索引为：2*i+2  
- i节点的父节点索引为：(i - 1) / 2 向下取整  

插入操作：  

- 新元素插入到最后面  
- 依次向上调整整个堆的结构，直到根节点  

删除最大值：  

- 将最后面元素放到第一个位置  
- 依次向下调整整个堆的结构，直到堆尾  

## 3.3 图 ##
图的属性：

- 点 V
- 入度 - 出度
- 点与点之间是否连通
- 边 E
- 有向 - 无向
- 权重（边长）

常见算法：

- DFS 深度优先搜索
- BFS 广度优先搜索


